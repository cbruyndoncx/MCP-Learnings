---
title: "Blog 3: Sessions, Context, and Lifecycle Management in `punkpeye-fastmcp`"
draft: false
---
## Blog 3: Sessions, Context, and Lifecycle Management in `punkpeye-fastmcp`

**Series:** Deep Dive into the Model Context Protocol SDKs (Advanced Topics)
**Post:** 3 of 12

Having explored how `punkpeye-fastmcp` simplifies defining [MCP primitives](blog-2.md) (`Tools`, `Resources`, `Prompts`) using its `add*` methods, we now shift our focus to the runtime aspects: how does the framework manage client connections (sessions), provide contextual information to your handler logic, and handle the overall server lifecycle?

Unlike purely stateless APIs, MCP often involves maintaining state per connection (e.g., for logging levels, resource subscriptions, or potentially complex tool interactions) and providing handlers with relevant session or request information. This post dives into the implementation details within `punkpeye-fastmcp`:

1.  **Session Management (`FastMCPSession`):** How individual client connections are represented and tracked.
2.  **The `Context` Object:** How handlers access session data, authentication info, logging, and progress reporting.
3.  **Authentication Hook:** Integrating custom authentication logic.
4.  **Server Lifecycle & Events:** The `start`/`stop` methods and the `connect`/`disconnect` events.

### 1. Session Management: Tracking Connections

While the underlying `@modelcontextprotocol/sdk`'s `Server` and internal `McpSession` handle the core protocol state for *a* connection, `punkpeye-fastmcp` introduces its own explicit `FastMCPSession` class (`src/FastMCP.ts`) to manage and expose session-specific details and lifecycle events *at the framework level*.

**Key Aspects:**

*   **Creation:** A new `FastMCPSession` instance appears to be created for *each* client connection.
    *   *Stdio:* A single session is created when `server.start({ transportType: 'stdio' })` connects the internal official `Server` to the `StdioServerTransport`.
    *   *SSE:* The `startSSEServer` helper (from `mcp-proxy`, likely wrapping the official `SSEServerTransport`) is configured with a `createServer` callback. This callback is invoked *per connecting SSE client* and likely returns a *new* `FastMCPSession` instance associated with that specific SSE connection/transport instance.
*   **Tracking (`FastMCP.sessions`):** The main `FastMCP` instance maintains an array (`#sessions`) holding all currently active `FastMCPSession` instances.
*   **Session State:** Each `FastMCPSession` instance likely holds:
    *   A reference back to the main `FastMCP` server instance.
    *   The underlying official SDK `Server` instance *specific to that session's transport connection*. (This implies multiple internal `Server` instances might exist when using SSE, one per client, managed by the `mcp-proxy`/transport layer).
    *   The negotiated `ClientCapabilities`.
    *   The client-set `LoggingLevel`.
    *   The list of client `Roots`.
    *   The result of the `authenticate` function (if provided), stored in `#auth`.
*   **Lifecycle Events:**
    *   `FastMCP` emits `"connect"` with the new `FastMCPSession` instance when a client successfully connects and initializes.
    *   `FastMCP` emits `"disconnect"` with the `FastMCPSession` instance when a client disconnects (SSE stream closes or Stdio transport ends). The session is removed from the `#sessions` array.
    *   `FastMCPSession` itself emits `"error"` and `"rootsChanged"`.

**Implementation Insights:**

*   The framework abstracts the underlying transport's connection mechanism. For SSE, it relies on `mcp-proxy` (or similar logic) to map individual HTTP connections/SSE streams to distinct `FastMCPSession` instances, likely using unique session IDs generated by the transport.
*   Storing session instances directly in the main `FastMCP` object's array implies session state is primarily **in-memory**. This works well for single-process deployments but doesn't scale horizontally without external state management or sticky sessions at a load balancer level (a common limitation noted for stateful MCP servers).

### 2. The `Context` Object: Empowering Handlers

Directly interacting with the underlying official `Server` or transport objects within every Tool/Resource/Prompt handler would be cumbersome. `punkpeye-fastmcp` provides a simplified `Context` object (type alias `Context<T>` in `FastMCP.ts`) passed to the `execute` and `load` functions.

**How it's Created and Populated:**

*   When the central framework handler (registered via the underlying `Server.setRequestHandler`) is invoked for a specific request (`tools/call`, `resources/read`, etc.), it identifies the corresponding `FastMCPSession` for that connection.
*   It creates the `Context` object for that specific request invocation.
*   It populates the `Context` with:
    *   `session`: The authenticated session data (the result of the `authenticate` function, type `T`).
    *   `log`: An object with methods (`debug`, `info`, `warn`, `error`) that internally call the underlying `session.#server.sendLoggingMessage()` but only if the message level meets the client-set `session.loggingLevel`.
    *   `reportProgress`: An async function that wraps the underlying `session.#server.sendNotification({ method: 'notifications/progress', ... })` call, using the `progressToken` from the incoming request's `_meta` data.

**Usage in Handlers:**

```typescript
server.addTool({
  name: "process_data",
  parameters: z.object({ dataId: z.string() }),
  execute: async (args, context) => { // Context object passed as second arg
    // Access authenticated session data (if authenticate was used)
    const userId = context.session?.userId; // Assuming authenticate returned { userId: ... }
    if (!userId) { throw new UserError("Authentication required"); }

    // Use simplified logging
    context.log.info(`User ${userId} processing data ${args.dataId}`);

    // Report progress (only sends if client included progressToken)
    await context.reportProgress({ progress: 50, total: 100 });

    // ... perform work ...

    context.log.debug("Processing complete");
    return "Success";
  }
});
```

**Comparison:** This `Context` object provides a cleaner, more focused interface for common handler needs compared to the official SDK's `RequestHandlerExtra` (which exposes more, lower-level details like the `AbortSignal` and `sendRequest`). Python's `FastMCP` `Context` is very similar in purpose and methods provided. C#'s `RequestContext` combined with DI parameter injection offers a different but also powerful way to access context and dependencies. Java's `Exchange` object serves a similar role.

### 3. Authentication Hook (`ServerOptions.authenticate`)

Security is crucial. `punkpeye-fastmcp` provides a simple, synchronous hook for custom authentication logic.

*   **Mechanism:** The `authenticate` function provided in `FastMCP` constructor options is called *early* in the connection process (likely by the `createServer` callback passed to `startSSEServer` or equivalent Stdio logic).
*   **Input:** It receives the raw incoming request object (e.g., Node.js `http.IncomingMessage` for SSE). This allows inspecting headers (`Authorization: Bearer ...`, `X-API-Key`, cookies, etc.).
*   **Output:**
    *   **Success:** Return an object (`T`) containing the authenticated user/session data. This object is stored and made available later via `context.session`.
    *   **Failure:** Throw an `Error` or, more appropriately for HTTP, throw a `Response` object (`new Response(null, { status: 401 })`). Throwing a `Response` allows controlling the exact HTTP status code and headers sent back to the unauthorized client.
*   **Simplicity vs. Robustness:** This provides a basic, flexible hook. However, it lacks the structure, standard compliance, and features (token types, grant flows, revocation, discovery) of a full OAuth 2.1 implementation like the one provided by the official TS SDK's `mcpAuthRouter`. Developers using this hook need to implement all token validation, scope checking, etc., manually.

### 4. Server Lifecycle (`start`/`stop`) and Events

*   **`server.start(options)`:**
    *   The primary method to begin listening for connections.
    *   Takes transport options (`stdio` or `sse`).
    *   For `stdio`, it creates an `StdioServerTransport`, creates a single `FastMCPSession`, connects it via the internal `Server`, emits `"connect"`, and waits for the transport to close (usually when stdin closes), then emits `"disconnect"`.
    *   For `sse`, it calls `startSSEServer` (from `mcp-proxy`), providing the `createServer` callback which instantiates `FastMCPSession` for each new connection and hooks up the `onConnect`/`onClose` events to emit `"connect"`/`"disconnect"`. Stores the underlying HTTP server handle.
*   **`server.stop()`:**
    *   For `stdio`, it likely cancels the underlying session's processing loop and disposes the transport.
    *   For `sse`, it calls `close()` on the underlying HTTP server returned by `startSSEServer`.
*   **Events (`connect`, `disconnect`):** Allow application code to react to clients joining or leaving, useful for tracking active users, resource cleanup, or metrics.

**Implementation Nuances:**

*   The reliance on `mcp-proxy` for SSE startup abstracts away the direct use of the official SDK's `SSEServerTransport`. While convenient, it means the server is tied to that library's implementation and the *legacy* SSE transport model.
*   Error handling during `start` (e.g., port already in use) depends on the underlying `http.Server` or `StdioServerTransport` behavior.

### Conclusion: Abstraction with In-Memory State

`punkpeye-fastmcp` provides useful abstractions for managing the MCP server lifecycle and interacting with session context. The `FastMCPSession` class offers a tangible representation of connected clients, and the `Context` object simplifies common tasks like logging and progress reporting within handlers. The `authenticate` hook provides a basic mechanism for securing the server.

However, advanced developers must recognize the implications of these abstractions:

*   **Session State:** State is primarily **in-memory**, tied to `FastMCPSession` instances. Scaling beyond a single process requires externalizing state.
*   **Transport Abstraction:** The simplification provided by `server.start()` currently hides the use of the **legacy SSE transport** for web communication, foregoing the benefits of Streamable HTTP available in the underlying official SDK.
*   **Authentication:** The basic hook requires significant custom implementation for robust, standard-based authentication like OAuth 2.1.

This framework excels at providing ergonomic wrappers for common patterns but requires developers to understand the underlying mechanisms (and their limitations) when building complex, scalable, or highly secure applications.

Next, we examine the **transport layer** in more detail, specifically how Stdio and the legacy SSE model are implemented via the underlying SDK and helpers like `mcp-proxy`, in **Blog 4: Transports and Tooling - Under the Wrapper**.

---
