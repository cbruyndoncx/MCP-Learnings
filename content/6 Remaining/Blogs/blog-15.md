---
title: "Blog 15: Under the Microscope - Obscure Internals of MCP SDKs (TS, Py, C#, Java)"
draft: false
---
## Blog 15: Under the Microscope - Obscure Internals of MCP SDKs (TS, Py, C#, Java)

**Series:** Deep Dive into the Model Context Protocol SDKs (Advanced Topics)
**Post:** 15 of 10

We've covered the high-level APIs, patterns, and features of the official and prominent community Model Context Protocol (MCP) SDKs. For the truly curious developer, however, the real intrigue often lies in the non-obvious implementation details – the clever hacks, the subtle trade-offs, the platform-specific workarounds. How *exactly* do these SDKs translate the MCP specification into working code across such different ecosystems?

This post digs into the weeds, unearthing some "obscure gems" and comparing the internal approaches of the official SDKs (TypeScript, C#, Java) and the enhanced Python V2 framework (`jlowin-fastmcp`) in four key areas:

1.  **Schema Nuances:** Beyond basic definition – generation, validation sources, flexibility.
2.  **Session ID Handling:** Headers vs. Query Parameters across transports.
3.  **Request Correlation:** The machinery behind matching responses to requests.
4.  **Cancellation Internals:** How the `notifications/cancelled` flow interacts with running handlers.

**(Disclaimer: This involves peering into internal implementation details which may change between versions. It's for understanding, not necessarily for relying on undocumented behavior.)**

### 1. The Schema Shuffle: Generation, Validation, and Flexibility

While all SDKs represent MCP types, *how* they handle the associated JSON Schema and validation varies considerably.

*   **Schema Source & Generation:**
    *   **TS Official (`types.ts`):** Uses Zod schemas as the primary definition. JSON Schema for `tools/list` needs to be generated (e.g., using `zod-to-json-schema` by the developer or a higher-level framework).
    *   **Python Official (`mcp`/v1) / `jlowin-fastmcp` (`func_metadata.py`):** **Dynamically generates** Pydantic models from function type hints. Uses `model.model_json_schema()` on these *generated* models to produce the required `inputSchema` for `tools/list`.
    *   **C# Official (`AIFunctionMcpServerTool`):** **Generates** JSON Schema internally using `AIFunctionFactory`, which reflects on the method signature (excluding DI/context params).
    *   **Java Official (`ToolSpecification`):** Requires the developer to **manually provide** the `inputSchema` as a `String` or `Map` when creating the `Tool` metadata object. No built-in generation from method signatures.
    *   **TS `punkpeye`:** Accepts user-provided Zod/ArkType/Valibot schema. **Internally converts** this to JSON Schema using `xsschema`/`zod-to-json-schema` for `tools/list`.
    *   **Obscurity:** The Python and C# approaches automate schema generation, reducing duplication but tying the schema tightly to the reflection/introspection capabilities of Pydantic/AIFunctionFactory. Java requires the most manual effort. TS `punkpeye` adds a conversion step.

*   **Runtime Validation Source:**
    *   **TS Official (`Server.setRequestHandler`):** Takes an explicit Zod schema for validation *separate* from the handler function signature.
    *   **Python V1/V2 (`FastMCP`):** Validates against the **dynamically generated Pydantic model** derived from the handler's signature.
    *   **C# (`AIFunctionMcpServerTool`):** Validation occurs internally via the `AIFunction` invocation logic, likely using the **generated JSON schema** or reflection-based checks.
    *   **Java Official:** **No automatic validation** in the core session logic before calling the handler `BiFunction`. Validation is the handler's responsibility, potentially using the manually provided `inputSchema`.
    *   **TS `punkpeye`:** Uses the **original user-provided schema object** (Zod/ArkType/Valibot) via its `.parse()`/`.validate()` method.
    *   **Obscurity:** There's a potential disconnect in TS `punkpeye` if the *generated* JSON Schema (for `tools/list`) doesn't perfectly match the runtime validation behavior of the *original* Zod/ArkType/Valibot schema. Python and C# keep generation and validation closely linked (though potentially less flexible). Java puts the onus entirely on the handler developer.

### 2. Session ID Handling: Header vs. Query Parameter

How do stateful HTTP transports associate incoming client messages with the correct server-side session?

*   **Legacy HTTP+SSE (`2024-11-05` Spec):**
    *   **Mechanism:** Session ID is generated by the server, included in the `data:` field of the initial `event: endpoint` SSE message (as part of the message POST URL). The client extracts this ID and includes it as a **`?sessionId=...` query parameter** on all subsequent `POST /message` requests.
    *   **SDKs Using:** Java (All SSE Providers), Python (`SseServerTransport`), C# (Legacy `SseHandler`), TS (`SSEServerTransport`).
    *   **Obscurity:** This relies entirely on the client correctly parsing the endpoint event and appending the query parameter. It's slightly less conventional than using headers and potentially exposes the session ID in URL logs. Server-side routing needs to parse the query string. `mcp-proxy` likely handles this mapping for `punkpeye-fastmcp`.

*   **Streamable HTTP (`2025-03-26` Spec):**
    *   **Mechanism:** Session ID is generated by the server, sent back in the **`Mcp-Session-Id` HTTP response header** of the initial successful `POST` (often the `initialize` request). The client reads this header, stores the ID, and includes it as an **`Mcp-Session-Id` HTTP request header** on all subsequent `POST`, `GET`, and `DELETE` requests to the server's single endpoint.
    *   **SDKs Using:** TS Official (`StreamableHttp*Transport`), C# Official (`SseClientTransport` with `UseStreamableHttp=true`, `StreamableHttpHandler` in AspNetCore).
    *   **Obscurity:** Aligns better with standard HTTP session practices (like cookies, but stateless). Requires header parsing on both client and server. Enables stateless server deployments more easily if session state is external, as the header identifies the context without relying on a specific SSE connection being mapped. C#'s `HttpMcpSession` likely tracks sessions based on this header value.

**Key Takeaway:** Knowing which session ID mechanism is used by your chosen SDK and transport is vital for debugging connectivity, implementing custom clients/servers, or configuring proxies/load balancers correctly.

### 3. Request/Response Correlation: The Pending Request Map

How does an SDK ensure the `result` or `error` from the server gets delivered to the correct `await client.callTool(...)` call that initiated it, especially with concurrent requests?

*   **Mechanism:** All SDKs use a variation of a dictionary/map keyed by the `RequestId`.
    *   **Sending:** When `client.sendRequestAsync` (or equivalent low-level method) is called:
        1.  A unique `RequestId` is generated (if not provided).
        2.  A completion mechanism is created (e.g., `TaskCompletionSource<JsonRpcResponse>` in C#, Promise `resolve`/`reject` callbacks in TS, `Future`/`CompletableFuture` in Java, potentially an `anyio.Event` or queue in Python).
        3.  This completion mechanism is stored in the internal "pending requests" map, keyed by the `RequestId`.
        4.  The `JsonRpcRequest` (with the ID) is sent over the transport.
        5.  The `sendRequestAsync` method returns a `Task`/`Promise`/`Future`/`Mono` linked to the completion mechanism.
    *   **Receiving:** When the core session logic (`McpSession`/`BaseSession`) receives an incoming `JsonRpcResponse` or `JsonRpcError`:
        1.  It extracts the `id` from the message.
        2.  It looks up the `id` in the "pending requests" map.
        3.  If found, it retrieves the corresponding completion mechanism.
        4.  It removes the entry from the map.
        5.  It completes the `Task`/`Promise`/`Future`/`Mono` with the received message (either successfully with the result or exceptionally with the error).
        6.  If not found, it logs an error (received response for unknown request ID).
*   **Obscurity:**
    *   *Synchronization:* Access to this map must be thread-safe/concurrency-safe. C# uses `ConcurrentDictionary`. Others might use locks (`threading.Lock` in Python `BaseSession`) or rely on single-threaded event loop guarantees (TS).
    *   *Timeout Handling:* Timeouts typically work by setting a timer when the request is sent. If the timer expires before the response arrives, the timer callback attempts to *cancel* or *fail* the completion mechanism in the map (e.g., `TaskCompletionSource.TrySetException(new TimeoutException())`) and removes the entry.
    *   *Resource Leaks:* If responses are lost and timeouts don't fire correctly, entries could potentially leak in the map (though good implementations guard against this).

### 4. Cancellation Internals: Tying Notifications to Handlers

How does receiving `notifications/cancelled` stop work *already in progress* on the other end?

*   **Mechanism:** Requires tracking *incoming* requests currently being processed.
    *   **Server-Side (Handling Client Cancellation):**
        1.  When the server's core session logic receives a `JsonRpcRequest`, *before* invoking the user's handler:
            *   It creates a cancellation primitive (e.g., `CancellationTokenSource` in C#, `AbortController` in TS).
            *   It stores this primitive in a second internal map ("handling requests" or "in-flight"), keyed by the *incoming* `RequestId`.
            *   It passes the corresponding token/signal (`CancellationToken`, `AbortSignal`) to the handler function (e.g., via `RequestContext`, `RequestHandlerExtra`, or injected parameter).
        2.  When `notifications/cancelled` arrives:
            *   The notification handler looks up the `requestId` in the "handling requests" map.
            *   If found, it triggers cancellation on the stored primitive (e.g., `cts.Cancel()`).
            *   The handler logic (if properly written) detects this cancellation via the token/signal it received and aborts.
        3.  When the handler *completes* (either successfully or via cancellation/exception):
            *   The entry for that `RequestId` is removed from the "handling requests" map.
    *   **Client-Side (Handling Server Cancellation):** Similar logic applies if the client implements handlers for server-initiated requests (like `sampling/createMessage`).
*   **Obscurity:**
    *   *Resource Management:* Requires careful management of the cancellation primitives (e.g., ensuring `CancellationTokenSource.Dispose()` is called in C#) and reliable cleanup of the "handling requests" map entries.
    *   *Race Conditions:* As noted before, the cancellation notification might arrive *after* the handler has already completed, in which case triggering cancellation has no effect.

### Conclusion: The Devil is in the (Internal) Details

While high-level frameworks like FastMCP abstract away much of the protocol's complexity, a deep appreciation for the underlying mechanics is invaluable for advanced debugging, performance tuning, and extension. Understanding the subtle differences in how each SDK:

*   Generates or requires JSON Schemas, and where runtime validation occurs.
*   Identifies sessions over HTTP (headers vs. query parameters).
*   Correlates asynchronous requests and responses using internal maps and completion primitives.
*   Propagates cancellation signals from notifications to active handlers via dedicated tracking.

...allows developers to make more informed decisions, anticipate potential issues (like transport limitations or validation mismatches), and ultimately build more robust and reliable MCP applications, regardless of their chosen language ecosystem.

---
